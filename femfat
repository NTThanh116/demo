# -*- coding: utf-8 -*-
"""
Fill Excel template from CSV/XLSX with robust handling for merged cells.

- Auto-detect fileA type (CSV/XLSX)
- Clean column headers
- Safe write into template:
    * If target cell is inside a merged range -> UNMERGE once, then write
      (so mỗi dòng có giá trị riêng; không bị read-only)
- Prints missing mapping keys with suggestions
"""

import os
import sys
import pandas as pd
from difflib import get_close_matches
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter

# ================== CONFIG ==================
fileA    = "data_raw.csv"        # dữ liệu gốc (CSV hoặc XLSX)
fileB    = "template.xlsx"       # mẫu báo cáo
fileOut  = "report_filled.xlsx"  # kết quả
sheet_name = None                # None = active sheet; hoặc "TênSheet"
start_row  = 14                  # dòng bắt đầu điền

# Mapping theo header bạn chụp màn hình
mapping = {
    "NodeID": "I",                 # NID
    "Most_critical_1": "J",        # 開始
    "Most_critical_2": "K",        # 終了
    "damage_total": "M",           # トータル Damage
    "delta_gamma_max": "N",        # せん断ひずみ範囲
    "Damage_mechanical": "O",      # 機械ダメージ
    "delta_epsilon_nn": "Q",       # ひずみ速度 Δεnn
    "Normal_strain_rate": "R",     # enn
    "Effective_oxidation": "S",    # Kp_eff
    "Oxidation_Phasing": "T",      # 比率
    "Damage_environmental": "U",   # 酸化Damage
    "Creep_Phasing": "W",          # クリープ位相係数
    "Damage_creep": "X"            # クリープDamage
}
# ============================================


def read_data_auto(path: str) -> pd.DataFrame:
    ext = os.path.splitext(path)[1].lower()
    if ext in [".xlsx", ".xlsm", ".xltx", ".xltm"]:
        df = pd.read_excel(path, engine="openpyxl")
    elif ext in [".csv", ".txt", ".dat"]:
        try:
            df = pd.read_csv(path, encoding="utf-8-sig")
        except UnicodeDecodeError:
            df = pd.read_csv(path, encoding="cp932")
        if df.shape[1] == 1:
            df = pd.read_csv(path, sep=None, engine="python", encoding="utf-8-sig")
    else:
        raise ValueError(f"Unsupported file extension: {path}")
    return df


def clean_headers(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    df.columns = (
        df.columns.astype(str)
        .str.replace("\u3000", " ", regex=False)   # full-width space
        .str.replace(r"\s+", " ", regex=True)     # multi spaces -> one
        .str.strip()
    )
    return df


def suggest_missing_keys(df: pd.DataFrame, keys):
    missing = [k for k in keys if k not in df.columns]
    if missing:
        print("\n❗ Không tìm thấy các cột sau trong dữ liệu:", missing)
        for k in missing:
            print(f"  - Gợi ý gần '{k}': {get_close_matches(k, df.columns.tolist(), n=3)}")
    return missing


def load_template(path: str, sheet_name=None):
    wb = load_workbook(path)
    ws = wb.active if sheet_name is None else wb[sheet_name]
    return wb, ws


def coerce_scalar(x):
    if hasattr(x, "item"):
        try:
            return x.item()
        except Exception:
            return x
    return x


def write_cell_safe(ws, addr: str, value, unmerged_cache: set):
    """
    Ghi vào ô addr. Nếu addr nằm trong vùng merged:
      - unmerge vùng đó (một lần), rồi ghi thẳng vào addr.
    Điều này tránh lỗi 'MergedCell is read-only' và cho phép mỗi hàng có giá trị riêng.
    """
    # Nhanh: nếu worksheet không có merge -> ghi luôn
    if not ws.merged_cells.ranges:
        ws[addr] = value
        return

    # Kiểm tra xem addr thuộc vùng merge nào
    for m in list(ws.merged_cells.ranges):
        if addr in m:
            # Unmerge một lần
            rng = str(m)
            if rng not in unmerged_cache:
                ws.unmerge_cells(rng)
                unmerged_cache.add(rng)
            break

    ws[addr] = value


def main():
    # 1) Read data
    if not os.path.exists(fileA):
        print(f"❌ Không thấy file dữ liệu: {fileA}")
        sys.exit(1)
    df = read_data_auto(fileA)
    df = clean_headers(df)
    print("→ Các cột tìm thấy trong dữ liệu:\n", list(df.columns))

    # 2) Mapping check
    missing = suggest_missing_keys(df, mapping.keys())
    if missing:
        print("\n⚠️  Những cột thiếu sẽ được để trống khi ghi.")
    nrows = len(df)

    # 3) Open template
    if not os.path.exists(fileB):
        print(f"❌ Không thấy file template: {fileB}")
        sys.exit(1)
    wb, ws = load_template(fileB, sheet_name=sheet_name)

    # 4) Fill
    unmerged_cache = set()
    for i in range(nrows):
        row = df.iloc[i]
        excel_row = start_row + i
        for colA, colB in mapping.items():
            val = row[colA] if colA in df.columns else ""
            addr = f"{colB}{excel_row}"
            write_cell_safe(ws, addr, coerce_scalar(val), unmerged_cache)

    # 5) Save
    wb.save(fileOut)
    print(f"\n✅ Xuất file: {os.path.abspath(fileOut)}")
    print(f"   Sheet: {ws.title}, bắt đầu dòng: {start_row}, số dòng ghi: {nrows}")


if __name__ == "__main__":
    main()
